#Evaluate
###What is this?
The `Evaluate` instance is used primarily to test a specific `Feature`, for a particular [`Context`](./x.Context.md), 
evaluates to a specific [`Variant`](./x.Varaint.md) (usually `'on'` or `'off'`).
 
Its main usage expects a `boolean` returned, an example being: 
```
if ( featureflow.evaluate(featureKey, context).is(variant) ){
  ...Do some feature specific code for the targeted variant here...
}
``` 

It calculates this value by finding the correct [`Variant`](./x.Varaint.md) for the `Feature` specified by the `featureKey`
 and `Context` provided (optional).
###Constructor
####`new Evaluate(featureKey, [context], ...)`
The `Evaluate` class can only be instantiated by the [`FeatureflowClient`]('./2.FeatureflowClient.md) calling `featureflow.evaluate(...)`.

When instantiated, it must have access to the parent `FeatureflowClient's` features in realtime. 
This is because it isn't guaranteed the feature will be tested when the `Evaluate` object is instantiated.

###Interface
####`featureflow.evaluate(...).is(variant)`
- Returns: a `boolean` if the `featureKey` matches the `variant` provided
- Arguments:
  - `variant*` The value of the variant you are testing (e.g. `'on'` or `'off'`)
  
Example implementation:
```
# arguments: [variant]
# from new Evaluate(...): [this.featureKey, this.context]

evaluated = this.value() # see .value() below
sendEvaluateEvent(this.featureKey, variant, evaluated, this.context) # Send an event to featureflow.io with the expected and evaluated feature for the context
return value == evaluated
```

You might also consider implementing some helper functions for the default `Variant` cases:
```
featureflow.evaluate(...).isOn()   # equivalent to featureflow.evaluate(...).is('on')
featureflow.evaluate(...).isOff()  # equivalent to featureflow.evaluate(...).is('off')
```
  
  
####`featureflow.evaluate(...).value()`
- Returns: a `string` containing the evaluated `Variant`

Note: it is important that every time `.value()` is called it uses the most recent `Feature` from `FeatureflowClient`. 
As explained above, it isn't guaranteed that this method will be called directly after `new Evaluate()` so you will have
to have some way of referencing the most recent version of the `feature`.

See [`Feature`](./x.Feature.md) to see the structure of a feature.

Example implementation is as follows:
```
# from new Evaluate(...): [this.featureKey, this.context, this.defaultFeatureVariant]
# salt comes from featureflow.io and stored on featureflow, default to 1
feature = featureflow.getFeature(this.featureKey)

if (feature is defined) then
  if (feature.enabled is false) then
      return feature.offVariantKey
  endif
  
  foreach (rule in feature.rules) do
      ruleHasMatched = false # we dont assume a match until we prove it has matched
      
      if (rule.defaultRule == true) then
          ruleHasMatched = true
      else
          conditions = rule.audience.conditions
          
          if (conditions is null) then
              ruleHasMatched = true # because there are no conditions to test against
          else
              conditionsPassed = true # all conditions must pass for the rule to match
              
              foreach (condition in conditions) do
                  testResult = false
                  foreach (contextValue in context.values[condition.target]) do
                      if (Operators.evaluate(condition.operator, contextValue, condition.values)) then
                        testResult = true # one value has matched from the list, this condition will pass
                      endif   
                  done
                  
                  if (testResult is false) then
                      conditionsPassed = false # one condition has failed, therefore this fails
                  endif
              done
              
              if (conditionsPassed == true) then
                  ruleHasMatched = true # all conditions have passed
              endif
          endif
      endif
  
      # there is always a default rule so a value will always be returned
      if (ruleHasMatched == true) then
          hash = Helpers.calculateHash(salt, this.featureKey, this.context.key)
          variantValue = Helpers.getVariantValue(hash)
          return Helpers.getVariantSplitKey(rule.variantSplits, variantValue) 
      endif
  done
else
    if (this.defaultFeatureVariant is defined) then
        return this.defaultFeatureVariant
    else
        return 'off'
    endif
endif
```

See [Operators](./5.Operators.md) to see the different operators that need to be implemented

####Up Next: [4. Helpers](4.VariantHelpers.md)

